= Layout

include::common.adoc[]

== Overview

The Elements Library provides a comprehensive set of elements for laying out
elements in the view.

== Limits

Each element provides information on how it wants to be sized by means of
`min` and `max` limits: a hint that determine its actual extent and how it
will be placed in the view depending on available window space. The element's
`limits` member function determines the minimum and maximum extents of an
element:

[,c++]
----
view_limits limits(basic_context const& ctx) const;
----

+++<a name="view_limits">++++++</a>+++
See link:context[Context] for information about `basic_context`. `view_limits`
is a struct that gives us the `min` and `max` information:

[,c++]
----
struct view_limits
{
   point    min = {0.0, 0.0};
   point    max = {full_extent, full_extent};
};
----

For the purpose of this document, we will use these terms and expressions:

limits:: The limits of an element

limits.min:: The minimum limits of an element

limits.min.x:: The minimum horizontal limit of an element

limits.min.y:: The minimum vertical limit of an element

limits.max:: The maximum limits of an element

limits.max.x:: The maximum horizontal limit of an element

limits.max.y:: The maximum vertical limit of an element

horizontal limits:: (limits.min.x, limits.max.x)

vertical limits:: (limits.min.y, limits.max.y)

minimum limits:: (limits.min.x, limits.min.y)

maximum limits:: (limits.max.x, limits.max.y)

minimum horizontal limit:: limits.min.x

maximum horizontal limit:: limits.max.x

minimum vertical limit:: limits.min.y

maximum vertical limit:: limits.max.y

By default, an element has full limits: it is infinitely resizable:

[,c++]
----
constexpr view_limits full_limits = {
   {0.0, 0.0}
 , {full_extent, full_extent}
};
----

An element with `full_limits` can be resized from an empty point (zero x and
y size) up to the full extent of the screen, and beyond (if possible).

____
:point_right: `full_extent` is actually an implementation defined huge
number near the _maximum limits_ of the coordinate's data type (also
implementation defined).
____

* An element has a fixed horizontal size if this expression is true:
`limits.min.x == limits.max.x`.
* An element has a fixed vertical size if this expression is true:
`limits.min.y == limits.max.y`.

[discrete]
==== Examples

[,c++]
----
{{100, 100}, {100, 100}}; // Fixed size
----

[,c++]
----
{{100, 100}, {100, full_extent}}; // Fixed width, flexible height
----

[,c++]
----
{{100, 100}, {100, 200}}; // Fixed width, semi-flexible height (100 to 200)
----

'''

== Size Elements

Size elements override the _limits_ of an enclosed element. There is a
comprehensive list of size related elements in the Elements Library that can
be used for various purposes. This section catalogues all the available size
elements.

'''

=== limit

image::/layout/limit.svg[alt="limit", width=360px, role=center]

Overrides the _limits_ of an element.

==== Expression

[,c++]
----
limit(limits, subject)
----

==== Notation

[cols=2*]
|===
| `limits`
| Instance of <<view_limits,`view_limits`>>

| `subject`
| Instance of `Element`
|===

==== Semantics

. The _limits_ of `subject` will be set to the specified `limits`
constrained by the natural _limits_ of the `subject` (the natural _limits_
of the element will not be violated).
. Returns instance of `Proxy`.

=== fixed_size

image::/layout/fixed_size.svg[alt="fixed_size", width=318px, role=center]

Fixes the size of an enclosed element (`subject`).

==== Expression

[,c++]
----
fixed_size({width, height}, subject)
----

==== Notation

[cols=2*]
|===
| `width`, `height`
| `float`

| `subject`
| Instance of `Element`
|===

==== Semantics

. `subject` will be laid out with a fixed `width` and `height`, constrained
by the natural _limits_ of the `subject` (the natural _limits_ of the
element will not be violated).
. Returns instance of `Proxy`.

'''

=== hsize

image::/layout/hsize.svg[alt="hsize", width=232px, role=center]

Fixes the horizontal size of an enclosed element (`subject`).

==== Expression

[,c++]
----
hsize(width, subject)
----

==== Notation

[cols=2*]
|===
| `width`
| `float`

| `subject`
| Instance of `Element`
|===

==== Semantics

. `subject` will be laid out with a fixed `width`, constrained by the
natural _horizontal limits_ of the `subject` (the natural _horizontal
limits_ of the element will not be violated).
. The natural _vertical limits_ of `subject` will not be affected.
. Returns instance of `Proxy`.

'''

=== vsize

image::/layout/vsize.svg[alt="vsize", width=316px, role=center]

Fixes the _vertical limits_ of an enclosed element (`subject`).

==== Expression

[,c++]
----
vsize(height, subject)
----

==== Notation

[cols=2*]
|===
| `height`
| `float`

| `subject`
| Instance of `Element`
|===

==== Semantics

. `subject` will be laid out with a fixed `height`, constrained by the
natural _vertical limits_ of the `subject` (the natural _vertical limits_
of the element will not be violated).
. The natural _horizontal limits_ of `subject` will not be affected.
. Returns instance of `Proxy`.

'''

=== min_size

image::/layout/min_size.svg[alt="min_size", width=360px, role=center]

Overrides the _minimum limits_ of an enclosed element (`subject`).

==== Expression

[,c++]
----
min_size({width, height}, subject)
----

==== Notation

[cols=2*]
|===
| `width`, `height`
| `float`

| `subject`
| Instance of `Element`
|===

==== Semantics

. The _minimum limits_ of `subject` will be set to the specified `width` and
`height`, constrained by the natural _minimum limits_ of the `subject`.
. the natural _minimum limits_ of the element will not be violated.
. Returns instance of `Proxy`.

'''

=== hmin_size

image::/layout/hmin_size.svg[alt="hmin_size", width=233px, role=center]

Overrides the _minimum horizontal limit_ of an enclosed element (`subject`).

==== Expression

[,c++]
----
hmin_size(width, subject)
----

==== Notation

[cols=2*]
|===
| `width`
| `float`

| `subject`
| Instance of `Element`
|===

==== Semantics

. The _minimum horizontal limit_ of `subject` will be set to the specified
`width` constrained by the natural _horizontal minimum limits_ of the
`subject`.
. The natural _horizontal minimum limits_ of the element will not be
violated.
. Returns instance of `Proxy`.

'''

=== vmin_size

image::/layout/vmin_size.svg[alt="vmin_size", width=360px, role=center]

Overrides the _minimum vertical limit_ of an enclosed element (`subject`).

==== Expression

[,c++]
----
vmin_size(height, subject)
----

==== Notation

[cols=2*]
|===
| `height`
| `float`

| `subject`
| Instance of `Element`
|===

==== Semantics

. The _minimum vertical limit_ of `subject` will be set to the specified `height`
constrained by the natural vertical _minimum limits_ of the `subject`.
. The natural vertical _minimum limits_ of the element will not be violated.
. Returns instance of `Proxy`.

'''

=== max_size

image::/layout/max_size.svg[alt="max_size", width=360px, role=center]

Overrides the _maximum limits_ of an enclosed element (`subject`).

==== Expression

[,c++]
----
max_size({width, height}, subject)
----

==== Notation

[cols=2*]
|===
| `width`, `height`
| `float`

| subject
| Instance of `Element`
|===

==== Semantics

. The _maximum limits_ of `subject` will be set to the specified `width` and
`height`, constrained by the natural _maximum limits_ of the `subject`.
. The natural _maximum limits_ of the element will not be violated.
. Returns instance of `Proxy`.

'''

=== hmax_size

image::/layout/hmax_size.svg[alt="hmax_size", width=360px, role=center]

Overrides the _maximum horizontal limit_ of an enclosed element (`subject`).

==== Expression

[,c++]
----
hmax_size(width, subject)
----

==== Notation

[cols=2*]
|===
| `width`
| `float`

| `subject`
| Instance of `Element`
|===

==== Semantics

. The _maximum horizontal limit_ of `subject` will be set to the specified
`width` constrained by the natural _maximum horizontal limit_ of the
`subject`.
. The natural _maximum horizontal limit_ of the element will not be
violated.
. Returns instance of `Proxy`.

'''

=== vmax_size

image::/layout/vmax_size.svg[alt="vmax_size", width=360px, role=center]

Overrides the _maximum vertical limit_ of an enclosed element (`subject`).

==== Expression

[,c++]
----
vmax_size(height, subject)
----

==== Notation

[cols=2*]
|===
| `height`
| `float`

| `subject`
| Instance of `Element`
|===

==== Semantics

. The _maximum vertical limit_ of `subject` will be set to the specified
`height` constrained by the natural _maximum vertical limit_ of the
`subject`
. The natural _maximum vertical limit_ of the element will not be violated.
. Returns instance of `Proxy`.

'''

== Stretch Elements

Resizable elements are elements with _minimum limits_ that are less than the
_maximum limits_ in either x or y dimensions or both. Resizable elements can
therefore stretch if there is extra available space allocated to it beyond
its minimum limit. When two or more resizable elements are placed side by
side in an <<htile,htile>> or <<vtile,vtile>>, the element's "stretchiness"
determines how much extra space is given to it. The element's "stretchiness"
is determined by the element's `stretch` member function:

[,c++]
----
virtual view_stretch stretch() const;
----

where `view_stretch` is a struct declared as:

[,c++]
----
struct view_stretch
{
   float    x = 1.0;
   float    y = 1.0;
};
----

The `view_stretch` `x` and `y` members determine how much an element can
stretch in the x or y dimensions. The default is 1.0. A stretchiness value of
2.0 means that the element is able to stretch twice as much compared to its
siblings in an <<htile,htile>> or <<vtile,vtile>>, assuming they have the
default 1.0 stretchiness.

'''

=== hstretch

image::/layout/hstretch.svg[alt="hstretch", width=232px, role=center]

Overrides the horizontal stretchiness of an an enclosed element (`subject`).

==== Expression

[,c++]
----
hstretch(stretch, subject)
----

==== Notation

[cols=2*]
|===
| `stretch`
| A scalar value

| `subject`
| Instance of `Element`
|===

==== Semantics

. The `subject` will assume the given `stretch` value.
. The stretch value has no effect to elements with fixed horizontal size.
. Returns instance of `Proxy`.

For example, the image below shows how three elements are laid out in an
`htile`, with stretch values of `1.0`, `1.0` and `2.0`, respectively:

image::/layout/htile-stretch.svg[alt="htile-stretch", width=232px, role=center]

The element with the `2.0` stretch value stretches twice as much compared to
its siblings.

'''

=== vstretch

image::/layout/vstretch.svg[alt="vstretch", width=316px, role=center]

Overrides the vertical stretchiness of an an enclosed element (`subject`).

==== Expression

[,c++]
----
vstretch(stretch, subject)
----

==== Notation

[cols=2*]
|===
| `stretch`
| A scalar value

| `subject`
| Instance of `Element`
|===

==== Semantics

. The `subject` will assume the given `stretch` value.
. The stretch value has no effect to elements with fixed _vertical limits_.
. Returns instance of `Proxy`.

For example, the image below shows how three elements are laid out in an
`htile`, with stretch values of `0.5`, `1.0` and `1.5`, respectively:

image::/layout/vtile-stretch.svg[alt="vtile-stretch", width=232px, role=center]

The element with the `0.5` stretch value stretches half less, while the
element with the `1.5` stretches half more than the default.

'''

== Scale Element

The Elements Library is resolution independent and elements can be scaled up
or down to suit. The default scale is 1.0 (no scale).

'''

=== scale

The `scale` element changes the scale of its enclosed element (`subject`).

==== Expression

[,c++]
----
scale(scale_, subject)
----

==== Notation

[cols=2*]
|===
| `scale_`
| `float`

| `subject`
| Instance of `Element`
|===

==== Semantics

. The `subject` will scaled given the `scale_` value. A value > 1.0 scales
the element up (zoom in), while a value < 1.0 scales down (zoom out).
. Returns instance of `Proxy`.

'''

== Align Elements

An element can be aligned arbitrarily from 0.0 to 1.0 in either the x or y
dimensions, or both. There is a comprehensive list of align elements in The
Elements Library that can be used for various purposes. This section
catalogues all the available align elements.

'''

=== halign

image::/layout/halign.svg[alt="halign", width=345px, role=center]

Aligns the an enclosed element (`subject`) in the x-axis.

==== Expression

[,c++]
----
halign(align, subject)
----

==== Notation

[cols=2*]
|===
| `align`
| `float`

| `subject`
| Instance of `Element`
|===

==== Semantics

. Given a total allocated space `X`, `subject` will be positioned
horizontally to `X * align`.
. The `subject` will assume its _minimum horizontal limit_.
. Returns instance of `Proxy`.

==== Examples

. `halign(0.0) // align subject to the left`
. `halign(1.0) // align subject to the right`
. `halign(0.5) // align subject to the center`

'''

=== align_left

image::/layout/align_left.svg[alt="align_left", width=250px, role=center]

Left-aligns the an enclosed element (`subject`).

==== Expression

[,c++]
----
align_left(subject)
----

==== Notation

[cols=2*]
|===
| `subject`
| Instance of `Element`
|===

==== Semantics

. Equivalent to `halign(0.0, subject)`
. Returns instance of `Proxy`.

'''

=== align_center

image::/layout/align_center.svg[alt="align_center", width=250px, role=center]

Center-aligns the an enclosed element (`subject`).

==== Expression

[,c++]
----
align_center(subject)
----

==== Notation

[cols=2*]
|===
| `subject`
| Instance of `Element`
|===

==== Semantics

. Equivalent to `halign(0.5, subject)`
. Returns instance of `Proxy`.

'''

=== align_right

image::/layout/align_right.svg[alt="align_right", width=250px, role=center]

Right-aligns the an enclosed element (`subject`).

==== Expression

[,c++]
----
align_right(subject)
----

==== Notation

[cols=2*]
|===
| `subject`
| Instance of `Element`
|===

==== Semantics

. Equivalent to `halign(1.0, subject)`
. Returns instance of `Proxy`.

'''

=== valign

image::/layout/valign.svg[alt="valign", width=163px, role=center]

Aligns the an enclosed element (`subject`) in the y-axis.

==== Expression

[,c++]
----
valign(align, subject)
----

==== Notation

[cols=2*]
|===
| `align`
| `float`

| `subject`
| Instance of `Element`
|===

==== Semantics

. Given a total allocated space `Y`, `subject` will be positioned vertically
to `Y * align`.
. The `subject` will assume its _minimum vertical limit_.
. Returns instance of `Proxy`.

==== Examples

. `valign(0.0) // align subject to the top`
. `valign(1.0) // align subject to the right`
. `valign(0.5) // align subject to the middle`

'''

=== align_top

image::/layout/align_top.svg[alt="align_top", width=90px, role=center]

Aligns the an enclosed element (`subject`) to the top.

==== Expression

[,c++]
----
align_top(subject)
----

==== Notation

[cols=2*]
|===
| `subject`
| Instance of `Element`
|===

==== Semantics

. Equivalent to `valign(0.0, subject)`
. Returns instance of `Proxy`.

'''

=== align_middle

image::/layout/align_middle.svg[alt="align_middle", width=90px, role=center]

Aligns the an enclosed element (`subject`) to the middle.

==== Expression

[,c++]
----
align_middle(subject)
----

==== Notation

[cols=2*]
|===
| `subject`
| Instance of `Element`
|===

==== Semantics

. Equivalent to `valign(0.5, subject)`
. Returns instance of `Proxy`.

'''

=== align_bottom

image::/layout/align_bottom.svg[alt="align_bottom", width=90px, role=center]

Aligns the an enclosed element (`subject`) to the bottom.

==== Expression

[,c++]
----
align_bottom(subject)
----

==== Notation

[cols=2*]
|===
| `subject`
| Instance of `Element`
|===

==== Semantics

. Equivalent to `valign(1.0, subject)`
. Returns instance of `Proxy`.

'''

=== align_left_top

image::/layout/align_left_top.svg[alt="align_left_top", width=240px, role=center]

Aligns the an enclosed element (`subject`) to the left-top.

==== Expression

[,c++]
----
align_left_top(subject)
----

==== Notation

[cols=2*]
|===
| `subject`
| Instance of `Element`
|===

==== Semantics

. Equivalent to `align_left(align_top(subject))`
. Returns instance of `Proxy`.

'''

=== align_center_top

image::/layout/align_center_top.svg[alt="align_center_top", width=240px, role=center]

Aligns the an enclosed element (`subject`) to the center-top.

==== Expression

[,c++]
----
align_center_top(subject)
----

==== Notation

[cols=2*]
|===
| `subject`
| Instance of `Element`
|===

==== Semantics

. Equivalent to `align_center(align_top(subject))`
. Returns instance of `Proxy`.

'''

=== align_right_top

image::/layout/align_right_top.svg[alt="align_right_top", width=240px, role=center]

Aligns the an enclosed element (`subject`) to the right-top.

==== Expression

[,c++]
----
align_right_top(subject)
----

==== Notation

[cols=2*]
|===
| `subject`
| Instance of `Element`
|===

==== Semantics

. Equivalent to `align_right(align_top(subject))`
. Returns instance of `Proxy`.

'''

=== align_left_middle

image::/layout/align_left_middle.svg[alt="align_left_middle", width=240px, role=center]

Aligns the an enclosed element (`subject`) to the left-middle.

==== Expression

[,c++]
----
align_left_middle(subject)
----

==== Notation

[cols=2*]
|===
| `subject`
| Instance of `Element`
|===

==== Semantics

. Equivalent to `align_left(align_middle(subject))`
. Returns instance of `Proxy`.

'''

=== align_center_middle

image::/layout/align_center_middle.svg[alt="align_center_middle", width=240px, role=center]

Aligns the an enclosed element (`subject`) to the center-middle.

==== Expression

[,c++]
----
align_center_middle(subject)
----

==== Notation

[cols=2*]
|===
| `subject`
| Instance of `Element`
|===

==== Semantics

. Equivalent to `align_center(align_middle(subject))`
. Returns instance of `Proxy`.

'''

=== align_right_middle

image::/layout/align_right_middle.svg[alt="align_right_middle", width=240px, role=center]

Aligns the an enclosed element (`subject`) to the right-middle.

==== Expression

[,c++]
----
align_right_middle(subject)
----

==== Notation

[cols=2*]
|===
| `subject`
| Instance of `Element`
|===

==== Semantics

. Equivalent to `align_right(align_middle(subject))`
. Returns instance of `Proxy`.

'''

=== align_left_bottom

image::/layout/align_left_bottom.svg[alt="align_left_bottom", width=240px, role=center]

Aligns the an enclosed element (`subject`) to the left-bottom.

==== Expression

[,c++]
----
align_left_bottom(subject)
----

==== Notation

[cols=2*]
|===
| subject
| Instance of `Element`
|===

==== Semantics

. Equivalent to `align_left(align_bottom(subject))`
. Returns instance of `Proxy`.

'''

=== align_center_bottom

image::/layout/align_center_bottom.svg[alt="align_center_bottom", width=240px, role=center]

Aligns the an enclosed element (`subject`) to the center-bottom.

==== Expression

[,c++]
----
align_center_bottom(subject)
----

==== Notation

[cols=2*]
|===
| `subject`
| Instance of `Element`
|===

==== Semantics

. Equivalent to `align_center(align_bottom(subject))`
. Returns instance of `Proxy`.

'''

=== align_right_bottom

image::/layout/align_right_bottom.svg[alt="align_right_bottom", width=240px, role=center]

Aligns the an enclosed element (`subject`) to the right-bottom.

==== Expression

[,c++]
----
align_right_bottom(subject)
----

==== Notation

[cols=2*]
|===
| `subject`
| Instance of `Element`
|===

==== Semantics

. Equivalent to `align_right(align_bottom(subject))`
. Returns instance of `Proxy`.

'''

== Margin Elements

Margins add some space around elements. There is a comprehensive list of
margin elements in the Elements Library that can be used for various
purposes. This section catalogues all the available margin elements.

'''

=== margin

image::/layout/margin.svg[alt="margin", width=302px, role=center]

Adds a margin all around an enclosed element (`subject`).

==== Expression

[,c++]
----
margin({left, top, right, bottom}, subject)
----

==== Notation

[cols=2*]
|===
| `left`, `top`, `right`, `bottom`
| `float`

| `subject`
| Instance of `Element`
|===

==== Semantics

. Space is added to the left, top, right, and bottom of the subject with the
given parameters.
. The element's _limits_ is overridden to account for the additional space.
. The `margin` does not violate the natural _limits_ of the subject.
`margin` will respect the subject's min-max constraints and resizability.
. Returns instance of `Proxy`.

'''

=== margin_left

image::/layout/margin_left.svg[alt="margin_left", width=230px, role=center]

Adds a margin to the left of an enclosed element (`subject`).

==== Expression

[,c++]
----
margin_left(left, subject)
----

==== Notation

[cols=2*]
|===
| `left`
| `float`

| `subject`
| Instance of `Element`
|===

==== Semantics

. Space is added to the left of the subject with the given parameter.
. The element's _limits_ is overridden to account for the additional space.
. The `margin_left` does not violate the natural _limits_ of the subject.
`margin_left` will respect the subject's min-max constraints and
resizability.
. Returns instance of `Proxy`.

'''

=== margin_right

image::/layout/margin_right.svg[alt="margin_right", width=230px, role=center]

Adds a margin to the right of an enclosed element (`subject`).

==== Expression

[,c++]
----
margin_right(right, subject)
----

==== Notation

[cols=2*]
|===
| `right`
| `float`

| `subject`
| Instance of `Element`
|===

==== Semantics

. Space is added to the right of the subject with the given parameter.
. The element's _limits_ is overridden to account for the additional space.
. The `margin_right` does not violate the natural _limits_ of the subject.
`margin_right` will respect the subject's min-max constraints and
resizability.
. Returns instance of `Proxy`.

'''

=== margin_top

image::/layout/margin_top.svg[alt="margin_right", width=218px, role=center]

Adds a margin to the top of an enclosed element (`subject`).

==== Expression

[,c++]
----
margin_top(top, subject)
----

==== Notation

[cols=2*]
|===
| `top`
| `float`

| `subject`
| Instance of `Element`
|===

==== Semantics

. Space is added to the top of the subject with the given parameter.
. The element's _limits_ is overridden to account for the additional space.
. The `margin_top` does not violate the natural _limits_ of the subject.
`margin_top` will respect the subject's min-max constraints and
resizability.
. Returns instance of `Proxy`.

'''

=== margin_bottom

image::/layout/margin_bottom.svg[alt="margin_bottom", width=218px, role=center]

Adds a margin to the bottom of an enclosed element (`subject`).

==== Expression

[,c++]
----
margin_bottom(bottom, subject)
----

==== Notation

[cols=2*]
|===
| `bottom`
| `float`

| `subject`
| Instance of `Element`
|===

==== Semantics

. Space is added to the to the bottom of the subject with the given
parameter.
. The element's _limits_ is overridden to account for the additional space.
. The `margin_bottom` does not violate the natural _limits_ of the subject.
`margin_bottom` will respect the subject's min-max constraints and
resizability.
. Returns instance of `Proxy`.

'''

=== hmargin

(same as `margin_left_right`)

image::/layout/hmargin.svg[alt="hmargin", width=302px, role=center]

Adds a margin to the left and right sides of an enclosed element (`subject`).

==== Expressions

[,c++]
----
// variant 1
hmargin({left, right}, subject)

// variant 2
hmargin(left, right, subject)

// variant 3
margin_left_right({left, right}, subject)

// variant 4
margin_left_right(left, right, subject)
----

==== Notation

[cols=2*]
|===
| `left`, `right`
| `float`

| `subject`
| Instance of `Element`
|===

==== Semantics

. Space is added to the to the left and right sides of the subject with the
given parameters.
. The element's _limits_ is overridden to account for the additional space.
. The `hmargin` (and variants) does not violate the natural _limits_ of the
subject. `hmargin` (and variants) will respect the subject's min-max
constraints and resizability.
. Returns instance of `Proxy`.

'''

=== vmargin

(same as `margin_top_bottom`)

image::/layout/vmargin.svg[alt="vmargin", width=218px, role=center]

Adds a margin to the top and bottom sides of an enclosed element (`subject`).

==== Expressions

[,c++]
----
// variant 1
vmargin({top, bottom}, subject)

// variant 2
vmargin(top, bottom, subject)

// variant 3
margin_top_bottom({top, bottom}, subject)

// variant 4
margin_top_bottom(top, bottom, subject)
----

==== Notation

[cols=2*]
|===
| `top`, `bottom`
| `float`

| `subject`
| Instance of `Element`
|===

==== Semantics

. Space is added to the to the top and bottom sides of the subject with the
given parameters.
. The element's _limits_ is overridden to account for the additional space.
. The `vmargin` (and variants) does not violate the natural _limits_ of the
subject. `vmargin` (and variants) will respect the subject's min-max
constraints and resizability.
. Returns instance of `Proxy`.

'''

=== margin_left_top

image::/layout/margin_left_top.svg[alt="margin_left_top", width=232px, role=center]

Adds a margin to the left and top sides of an enclosed element (`subject`).

==== Expressions

[,c++]
----
// variant 1
margin_left_top({left, top}, subject)

// variant 2
margin_left_top(left, top, subject)
----

==== Notation

[cols=2*]
|===
| `left`, `top`
| `float`

| `subject`
| Instance of `Element`
|===

==== Semantics

. Space is added to the to the left and top sides of the subject with the
given parameters.
. The element's _limits_ is overridden to account for the additional space.
. The `margin_left_top` (and variant) does not violate the natural _limits_
of the subject. `margin_left_top` (and variant) will respect the subject's
min-max constraints and resizability.
. Returns instance of `Proxy`.

'''

=== margin_left_bottom

image::/layout/margin_left_bottom.svg[alt="margin_left_bottom", width=232px, role=center]

Adds a margin to the left and bottom sides of an enclosed element (`subject`).

==== Expressions

[,c++]
----
// variant 1
margin_left_bottom({left, bottom}, subject)

// variant 2
margin_left_bottom(left, bottom, subject)
----

==== Notation

[cols=2*]
|===
| `left`, `bottom`
| `float`

| `subject`
| Instance of `Element`
|===

==== Semantics

. Space is added to the to the left and bottom sides of the subject with the
given parameters.
. The element's _limits_ is overridden to account for the additional space.
. The `margin_left_bottom` (and variant) does not violate the natural
_limits_ of the subject. `margin_left_bottom` (and variant) will respect
the subject's min-max constraints and resizability.
. Returns instance of `Proxy`.

'''

=== margin_right_top

image::/layout/margin_right_top.svg[alt="margin_right_top", width=232px, role=center]

Adds a margin to the right and top sides of an enclosed element (`subject`).

==== Expressions

[,c++]
----
// variant 1
margin_right_top({right, top}, subject)

// variant 2
margin_right_top(right, top, subject)
----

==== Notation

[cols=2*]
|===
| `right`, `top`
| `float`

| `subject`
| Instance of `Element`
|===

==== Semantics

. Space is added to the to the right and top sides of the subject with the
given parameters.
. The element's _limits_ is overridden to account for the additional space.
. The `margin_right_top` (and variant) does not violate the natural _limits_
of the subject. `margin_right_top` (and variant) will respect the
subject's min-max constraints and resizability.
. Returns instance of `Proxy`.

'''

=== margin_right_bottom

image::/layout/margin_right_bottom.svg[alt="margin_right_bottom", width=232px, role=center]

Adds a margin to the right and bottom sides of an enclosed element (`subject`).

==== Expressions

[,c++]
----
// variant 1
margin_right_bottom({right, bottom}, subject)

// variant 2
margin_right_bottom(right, bottom, subject)
----

==== Notation

[cols=2*]
|===
| `right`, `bottom`
| `float`

| `subject`
| Instance of `Element`
|===

==== Semantics

. Space is added to the to the right and bottom sides of the subject with the
given parameters.
. The element's _limits_ is overridden to account for the additional space.
. The `margin_right_bottom` (and variant) does not violate the natural
limits of the subject. `margin_right_bottom` (and variant) will respect
the subject's min-max constraints and resizability.
. Returns instance of `Proxy`.

'''

== Floating Element

image::/layout/floating.svg[alt="floating", width=432px, role=center]

A floating element allows arbitrary placement of an enclosed element
(`subject`) in the main view.

[discrete]
==== Expression

[,c++]
----
floating({left, top, right, bottom}, subject)
----

[discrete]
==== Notation

[cols=2*]
|===
| `left`, `top`, `right`, `bottom`
| `float`

| `subject`
| Instance of `Element`
|===

[discrete]
==== Semantics

. The element will be placed exactly to the specified position in the main
view, constrained to the subject's natural _limits_.
. The floating element does not violate the natural _limits_ of the subject.
. Returns instance of `Proxy`.

'''

== Tiles and Grids

Tiles are the most useful layout elements, followed by by Grids. Tiles are
used everywhere for composing hierarchical elements in rows and columns,
typical to all GUIs. Grids are similar to tiles. Both tiles and grids allow
elements to fluidly adjust depending on available space. Tiles compute the
layout of its elements using the children elements' size `limits` while grids
lay out its elements using an externally supplied fractional coordinates that
specify positions of the elements in the allocated space.

Tiles are best used
for composing UI elements while grids are best for composing tables.

'''

=== Horizontal Grids

image::/layout/hgrid.svg[alt="hgrid", width=347px, role=center]

Horizontal Grids are composites that lay out one or more child elements in a
row following externally supplied horizontal fractional positions. Horizontal
Grids have computed horizontal and vertical sizes following the natural
`limits` of its children.

==== Semantics

. The elements are laid out in a single row, left to right, immediately next
to each other with no intervening space.
. The elements are positioned horizontally using the supplied fractional
positions. The fractional positions values range from 0.0 to 1.0, which
specify the child element's horizontal position from left (0.0) to right
(1.0).
. The grid's _minimum vertical limit_ is computed as the maximum of the
children elements' __minimum vertical limit__s.
. The grid's _maximum vertical limit_ is computed as the minimum of the
children elements' __maximum vertical limit__s.
. The final computed minimum limit is clamped to ensure it is not greater
than the computed maximum limit. Likewise the computed maximum limit is
clamped to ensure it is not less than the computed minimum limit.
. The supplied (horizontal) positions and computed (vertical) coordinates
may violate the limits of its children elements.
 .. If the allocated size of a child element is lower than the element's
_minimum limits_ in either dimension, the element will be cropped.
 .. If a child element's _maximum limits_ in either dimension is exceeded,
the element will be aligned to the top-left.

'''

=== hgrid

Build a horizontal grid with a fixed number of elements.

==== Expression

[,c++]
----
hgrid(positions, e1,...eN)
----

==== Notation

[cols=2*]
|===
| `N`
| The number of items

| `+e1,...eN+`
| One or more child elements, instances of `Element` (more below)

| `positions`
| External container of fractional positions (more below)
|===

The external container, `positions`, can either be a plain array of type
`float[N]` or `std::array<float, N>`. Elements `+e1,...eN+` are held in a
`std::array<element_ptr, N>` managed by the horizontal grid element.

==== Example

[,c++]
----
static float positions[] = {0.25, 0.5, 0.75, 1.0};
//...
hgrid(positions, item1, item2, item3, item4)
----

____
:point_right: If the number of elements is not fixed, you can use an
`hgrid_composite` (see below).
____

==== Requirements

. The number of supplied positions and elements should match, otherwise,
compiler error (no matching function for call to `hgrid`).
. The positions assume the first element is at `x=0` (it is at the left-most
position in the row). The fractional position of the second element is at
index `0`, the third at index `1`, and so on.
. The externally supplied positions should be sorted with increasing values
such that positions[n] \<= positions[n+1]. The behavior is undefined if
this is violated.

==== Semantics

. In addition to the semantics of Horizontal Grids, returns instance of
`Composite`.

'''

=== hgrid_composite

Create a horizontal grid with an indeterminate (dynamic) number of elements.

==== Expression

[,c++]
----
hgrid_composite c{positions};
----

==== Notation

[cols=2*]
|===
| `positions`
| External container of fractional positions, `std::vector<float>`

| `c`
| Instance of type `hgrid_composite`
|===

The `hgrid_composite` is basically a `std::vector<element_ptr>` that the
client uses to manage the composite's elements. The lifetime of the
container, `c`, is the client's responsibility. You use `hgrid_composite`
just as you would a `std::vector`, such as `push_back` a child element. Just
keep in mind that we are dealing with `element_ptr` items.

==== Example

[,c++]
----
c.push_back(share(child));
----

____
:point_right: `share` turns an element object into an `element_ptr` held by
the `std::vector<element_ptr>` in `hgrid_composite`.
____

`hgrid_composite` is itself also an `element` and while it has ``std::vector``'s
interface, it can also be ``share``d like any element, which allows you to
build complex hierarchical structures.

==== Requirements

. The number of items in the external coordinates vector `positions` must match
with the number of elements at any given time.
. The positions assume the first element is at `x=0` (it is at the left-most
position in the row). The fractional position of the second element is at
index `0`, the third at index `1`, and so on.
. The externally supplied positions should be sorted with increasing values
such that positions[n] \<= positions[n+1]. The behavior is undefined if
this is violated.

'''

=== Horizontal Tiles

image::/layout/htile.svg[alt="htile", width=462px, role=center]

Horizontal Tiles are similar to Horizontal Grids, but allow elements to
fluidly adjust horizontally depending on available space. Horizontal Tiles
are best used for composing UI elements while Horizontal Grids are best for
composing tables.

==== Semantics

. The elements are laid out in a single row, left to right, immediately next
to each other with no intervening space.
. The elements are positioned horizontally using the children's natural
_limits_.
. Horizontal space is allocated using this algorithm:
 .. Space is allocated for each child element following the child's natural
_minimum horizontal limit_.
 .. If the allocated space exceeds the sum of all children elements'
__minimum horizontal limit__s, the extra space is given to each
horizontally resizable element (`limits.min.x < limits.max.x`).
 .. The element's "stretchiness" determines how much extra space is given
to it according to the element's `stretch()` member function. A stretch
value of `1.0` is default. A stretchiness value of 2.0 means that the
element is able to stretch twice as much compared to its siblings.
Horizontally fixed-sized elements will not be stretched (element d in
the diagram). (Also see <<stretch-elements,Stretch Elements>>).
. The tile's _minimum vertical limit_ is computed as the maximum of the
children elements' __minimum vertical limit__s.
. The grid's _maximum vertical limit_ is computed as the minimum of the
children elements' __maximum vertical limit__s.
. The final computed minimum limit is clamped to ensure it is not greater
than the computed maximum limit. Likewise the computed maximum limit is
clamped to ensure it is not less than the computed minimum limit.
. The supplied (horizontal) and computed (vertical) coordinates may violate
the limits of its children elements.
 .. If the allocated size of a child element is lower than the element's
_minimum limits_ in either dimension, the element will be cropped.
 .. If a child element's _maximum limits_ in either dimension is exceeded,
the element will be aligned to the top-left.

'''

=== htile

Build a horizontal tile with a fixed number of elements.

==== Expression

[,c++]
----
htile(e1,...eN)
----

==== Notation

[cols=2*]
|===
| `N`
| The number of items

| `+e1,...eN+`
| One or more child elements, instances of `Element` (more below)
|===

Elements `+e1,...eN+` are held in a `std::array<element_ptr, N>` managed by the
horizontal tile element.

==== Example:

[,c++]
----
htile(item1, item2, item3, item4)
----

____
:point_right: If the number of elements is not fixed, you can use an
`htile_composite` (see below).
____

==== Semantics

. In addition to the semantics of Horizontal Tiles, returns instance of
`Composite`.

'''

=== htile_composite

Create a horizontal tile with an indeterminate (dynamic) number of elements.

==== Expression

[,c++]
----
htile_composite c;
----

==== Notation

[cols=2*]
|===
| `c`
| Instance of type `htile_composite`
|===

The `htile_composite` is basically a `std::vector<element_ptr>` that the
client uses to manage the composite's elements. The lifetime of the
container, `c`, is the client's responsibility. You use `htile_composite`
just as you would a `std::vector`, such as `push_back` a child element. Just
keep in mind that we are dealing with `element_ptr` items.

==== Example

[,c++]
----
c.push_back(share(child));
----

____
:point_right: `share` turns an element object into an `element_ptr` held by
the `std::vector<element_ptr>` in `htile_composite`.
____

`htile_composite` is itself also an `element` and while it has ``std::vector``'s
interface, it can also be ``share``d like any element, which allows you to
build complex hierarchical structures.

'''

=== Vertical Grids

image::/layout/vgrid.svg[alt="vgrid", width=347px, role=center]

Vertical Grids are composites that lay out one or more child elements in a
column following externally supplied vertical fractional positions. Vertical
Grids have computed horizontal and vertical sizes following the natural
`limits` of its children.

==== Semantics

. The elements are laid out in a single column, top to bottom, immediately
next to each other with no intervening space.
. The elements are positioned vertically using the supplied fractional
positions. The fractional positions values range from 0.0 to 1.0, which
specify the child element's vertical position from top (0.0) to bottom
(1.0).
. The grid's _minimum horizontal limit_ is computed as the maximum of the
children elements' __minimum horizontal limit__s.
. The grid's _maximum horizontal limit_ is computed as the minumum of the
children elements' __maximum horizontal limit__s.
. The final computed minimum limit is clamped to ensure it is not greater
than the computed maximum limit. Likewise the computed maximum limit is
clamped to ensure it is not less than the computed minimum limit.
. The supplied (vertical) positions and computed (horizontal) coordinates
may violate the limits of its children elements.
 .. If the allocated size of a child element is lower than the element's
_minimum limits_ in either dimension, the element will be cropped.
 .. If a child element's _maximum limits_ in either dimension is exceeded,
the element will be aligned to the top-left.

'''

=== vgrid

Build a vertical grid with a fixed number of elements.

==== Expression

[,c++]
----
vgrid(positions, e1,...eN)
----

==== Notation

[cols=2*]
|===
| `N`
| The number of items

| `+e1,...eN+`
| One or more child elements, instances of `Element` (more below)

| `positions`
| External container of fractional positions (more below)
|===

The External container, `positions` is an external can either be a plain array
of type `float[N]` or `std::array<float, N>`. Elements `+e1,...eN+` are held in
a `std::array<element_ptr, N>` managed by the vertical grid element.

==== Example

[,c++]
----
static float positions[] = {0.25, 0.5, 0.75, 1.0};
//...
vgrid(positions, item1, item2, item3, item4)
----

____
:point_right: If the number of elements is not fixed, you can use an
`vgrid_composite` (see below).
____

==== Requirements

. The number of supplied coordinates and elements should match, otherwise,
compiler error (no matching function for call to `vgrid`).
. The positions assume the first element is at `x=0` (it is at the top-most
position in the column). The fractional position of the second element is at
index `0`, the third at index `1`, and so on.
. The externally supplied positions should be sorted with increasing values
such that positions[n] \<= positions[n+1]. The behavior is undefined if
this is violated.

==== Semantics

. In addition to the semantics of Vertical Grids, returns instance of
`Composite`.

'''

=== vgrid_composite

Create a vertical grid with an indeterminate (dynamic) number of elements.

==== Expression

[,c++]
----
vgrid_composite c{positions};
----

==== Notation

[cols=2*]
|===
| `positions`
| External container of fractional positions, `std::vector<float>`

| `c`
| Instance of type `vgrid_composite`
|===

The `vgrid_composite` is basically a `std::vector<element_ptr>` that the
client uses to manage the composite's elements. The lifetime of the
container, `c`, is the client's responsibility. You use `vgrid_composite`
just as you would a `std::vector`, such as `push_back` a child element. Just
keep in mind that we are dealing with `element_ptr` items. Example:

[,c++]
----
c.push_back(share(child));
----

____
:point_right: `share` turns an element object into an `element_ptr` held by
the `std::vector<element_ptr>` in `vgrid_composite`.
____

`vgrid_composite` is itself also an `element` and while it has ``std::vector``'s
interface, it can also be ``share``d like any element, which allows you to
build complex hierarchical structures.

==== Requirements

. The number of items in the external coordinates vector `positions` must match
with the number of elements at any given time.
. The positions assume the first element is at `x=0` (it is at the top-most
position in the column). The fractional position of the second element is at
index `0`, the third at index `1`, and so on.
. The externally supplied positions should be sorted with increasing values
such that positions[n] \<= positions[n+1]. The behavior is undefined if
this is violated.

'''

=== Vertical Tiles

image::/layout/vtile.svg[alt="vtile", width=347px, role=center]

Vertical Tiles are similar to Vertical Grids, but allow elements to fluidly
adjust vertically depending on available space. Vertical Tiles are best used
for composing UI elements while Vertical Grids are best for composing tables.

==== Semantics

. The elements are laid out in a single column, left to right, immediately
next to each other with no intervening space.
. The elements are positioned vertically using the children's natural
_limits_.
. Vertical space is allocated using this algorithm:
 .. Space is allocated for each child element following the child's natural
_minimum vertical limit_.
 .. If the allocated space exceeds the sum of all children elements'
__minimum vertical limit__s, the extra space is given to each
vertically resizable element (`limits.min.y < limits.max.y`).
 .. The element's "stretchiness" determines how much extra space is given
to it according to the element's `stretch()` member function. A stretch
value of `1.0` is default. A stretchiness value of 2.0 means that the
element is able to stretch twice as much compared to its siblings.
Vertically fixed-sized elements will not be stretched (element b in the
diagram). (Also see <<stretch-elements,Stretch Elements>>).
. The tile's _minimum horizontal limit_ is computed as the maximum of the
children elements' __minimum horizontal limit__s.
. The grid's _maximum horizontal limit_ is computed as the minumum of the
children elements' __maximum horizontal limit__s.
. The final computed minimum limit is clamped to ensure it is not greater
than the computed maximum limit. Likewise the computed maximum limit is
clamped to ensure it is not less than the computed minimum limit.
. The supplied (vertical) and computed (horizontal) coordinates may violate
the limits of its children elements.
 .. If the allocated size of a child element is lower than the element's
_minimum limits_ in either dimension, the element will be cropped.
 .. If a child element's _maximum limits_ in either dimension is exceeded,
the element will be aligned to the top-left.

'''

=== vtile

Build a vertical tile with a fixed number of elements.

==== Expression

[,c++]
----
vtile(e1,...eN)
----

==== Notation

[cols=2*]
|===
| `N`
| The number of items

| `+e1,...eN+`
| One or more child elements, instances of `Element` (more below)
|===

Elements `+e1,...eN+` are held in a `std::array<element_ptr, N>` managed by the
vertical tile element.

==== Example

[,c++]
----
vtile(item1, item2, item3, item4)
----

____
:point_right: If the number of elements is not fixed, you can use an
`vtile_composite` (see below).
____

==== Semantics

. In addition to the semantics of Vertical Tiles, returns instance of
`Composite`.

'''

=== vtile_composite

Create a vertical tile with an indeterminate (dynamic) number of elements:

==== Expression

[,c++]
----
vtile_composite c;
----

==== Notation

[cols=2*]
|===
| `c`
| Instance of type `vtile_composite`
|===

The `vtile_composite` is basically a `std::vector<element_ptr>` that the
client uses to manage the composite's elements. The lifetime of the
container, `c`, is the client's responsibility. You use `vtile_composite`
just as you would a `std::vector`, such as `push_back` a child element. Just
keep in mind that we are dealing with `element_ptr` items.

==== Example

[,c++]
----
c.push_back(share(child));
----

____
:point_right: `share` turns an element object into an `element_ptr` held by
the `std::vector<element_ptr>` in `vtile_composite`.
____

`vtile_composite` is itself also an `element` and while it has
``std::vector``'s interface, it can also be ``share``d like any element, which
allows you to build complex hierarchical structures.

'''

== Layers

image::/layout/layer.svg[alt="layer", width=353px, role=center]

The Elements Library is 2D, but the z-axis pertains to top-to-bottom
layering. Layers allow groups of elements to be placed in the z-axis where
higher-level elements obscure or hide lower-level elements.

[discrete]
==== Semantics

. The elements are laid out in the z-axis, top to bottom.
. Rendering is done bottom-up; the bottom-most elements are drawn first.
. UI control (such as mouse clicks) proceeds from top to bottom.
Higher-level elements are given control priority. If a higher-level
element does not process the event, lower-level elements are given a
chance.
. The layer's _minimum limit_ is computed as the maximum of the children
elements' __minimum limit__s.
. The layer's _maximum limit_ is computed as the minimum of the children
elements' __maximum limit__s.
. The final computed minimum limit is clamped to ensure it is not greater
than the computed maximum limit. Likewise the computed maximum limit is
clamped to ensure it is not less than the computed minimum limit.
. The computed (vertical) and (horizontal) coordinates may violate the
limits of its children elements.
 .. If the allocated size of a child element is lower than the element's
_minimum limits_ in either dimension, the element will be cropped.
 .. If a child element's _maximum limits_ in either dimension is exceeded,
the element will be aligned to the top-left.

'''

=== layer

Create a layer composite with a fixed number of elements.

==== Expression

[,c++]
----
layer(e1,...eN)
----

==== Notation

[cols=2*]
|===
| `N`
| The number of items

| `+e1,...eN+`
| One or more child elements, instances of `Element` (more below)
|===

Elements `+e1,...eN+` are held in a `std::array<element_ptr, N>` managed by the
layer element.

==== Example

[,c++]
----
layer(item1, item2, item3, item4)
----

____
:point_right: If the number of elements is not fixed, you can use an
`layer_composite` (see below).
____

==== Semantics

. In addition to the semantics of Layers, returns instance of `Composite`.

'''

=== layer_composite

Create a layer with an indeterminate (dynamic) number of elements:

[,c++]
----
layer_composite c;
----

==== Notation

[cols=2*]
|===
| `c`
| Instance of type `layer_composite`
|===

The `layer_composite` is basically a `std::vector<element_ptr>` that the
client uses to manage the composite's elements. The lifetime of the
container, `c`, is the client's responsibility. You use `layer_composite`
just as you would a `std::vector`, such as `push_back` a child element. Just
keep in mind that we are dealing with `element_ptr` items.

==== Example

[,c++]
----
c.push_back(share(child));
----

____
:point_right: `share` turns an element object into an `element_ptr` held by
the `std::vector<element_ptr>` in `layer_composite`.
____

`layer_composite` is itself also an `element` and while it has
``std::vector``'s interface, it can also be ``share``d like any element, which
allows you to build complex hierarchical structures.

'''

=== Decks

image::/layout/deck.svg[alt="deck", width=353px, role=center]

The Deck is very similar to layers. Elements are placed in the z-axis. But
unlike layers, only the selected element is active (top-most by default).

==== Semantics

. Everything listed in the layer's _Semantics_, except 2 and 3.
. Only the active selected element element is drawn.
. Only the active selected element is given the chance to process UI control.

'''

=== deck

Create a deck composite with a fixed number of elements.

==== Expression

[,c++]
----
deck(e1, e2, e3... eN)
----

==== Notation

[cols=2*]
|===
| `N`
| The number of items

| `+e1,...eN+`
| One or more child elements, instances of `Element` (more below)
|===

Elements `+e1,...eN+` are held in a `std::array<element_ptr, N>` managed by the
deck element.

==== Example

[,c++]
----
deck(item1, item2, item3, item4)
----

____
:point_right: If the number of elements is not fixed, you can use an
`deck_composite` (see below).
____

==== Requirements

. In addition to the semantics of Deck, returns instance of `Composite`.

'''

=== deck_composite

Create a deck with an indeterminate (dynamic) number of elements:

==== Expression

[,c++]
----
deck_composite c;
----

==== Notation

[cols=2*]
|===
| `c`
| Instance of type `deck_composite`
|===

The `deck_composite` is basically a `std::vector<element_ptr>` that the
client uses to manage the composite's elements. The lifetime of the
container, `c`, is the client's responsibility. You use `deck_composite`
just as you would a `std::vector`, such as `push_back` a child element. Just
keep in mind that we are dealing with `element_ptr` items.

==== Example

[,c++]
----
c.push_back(share(child));
----

____
:point_right: `share` turns an element object into an `element_ptr` held by
the `std::vector<element_ptr>` in `deck_composite`.
____

`deck_composite` is itself also an `element` and while it has ``std::vector``'s
interface, it can also be ``share``d like any element, which allows you to
build complex hierarchical structures.

'''

== Flow Element

The flow element, is a composite that lays out its children much like the way
text is laid out: lay out each element from left to right, fitting as much
elements as possible following each child's _maximum horizontal limit_. Once
a row is full, move to the next row and do the same until the end of the row
is filled. Repeat the procedure until all the elements are laid out. The
height of each row is determined by the _maximum vertical limit_ of all the
elements to be laid out in that row. The following graphic depicts a
simplified layout scenario for child elements `a` to `r`.

image::/layout/flow.svg[alt="flow", width=380px, role=center]

The child elements arranged in a `flow` composite are automatically re-flowed
(re-lay-out) when the view size changes.

To have elements laid out using `flow`, you need to make a `flow_composite`.

'''

=== flow_composite

Create a `flow_composite` with an indeterminate (dynamic) number of elements.

==== Expression

[,c++]
----
flow_composite c;
----

==== Notation

[cols=2*]
|===
| `c`
| Instance of type `flow_composite`
|===

The `flow_composite` is basically a `std::vector<element_ptr>` that the
client uses to manage the composite's elements. The lifetime of the
container, `c`, is the client's responsibility. You use `flow_composite` just
as you would a `std::vector`, such as `push_back` a child element, `child`.
Just keep in mind that we are dealing with `element_ptr` items.

==== Example

[,c++]
----
c.push_back(share(child));
----

____
:point_right: `share` turns an element object into an `element_ptr` held by
the `std::vector<element_ptr>` in `flow_composite`.
____

`flow_composite` is itself also an `element` and while it has ``std::vector``'s
interface, it can also be ``share``d like any element, which allows you to
build complex hierarchical structures.

'''

=== flow

Once we have a `flow_composite`, we can place its contents in a `flow`
element.

==== Expression

[,c++]
----
flow(c)
----

==== Notation

[cols=2*]
|===
| `c`
| Instance of `flow_composite`
|===

==== Semantics

. Returns instance of `Composite`.

'''

_Copyright (c) 2014-2024 Joel de Guzman. All rights reserved._
_Distributed under the {mit_license}_
